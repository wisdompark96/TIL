# 문서관리 시스템
## 목표
다양한 소프트웨어 개발 원칙을 배운다. 문서 관리 기능 설계의 핵심은 상속 관계, 즉 어떻게 클래스를 상속하거나 인터페이스를 구현하는가에 달렸다.
언제 상속을 사용해야 하는지와 관련해서는 '상속보다 조합'원칙도 알아야 한다.

## 문서 관리 시스템 요구 사항
문서 관리 시스템은 기존 환자 정보 파일을 읽어 색인을 추가하고 검색할 수 있는 형태의 정보로 변환해야 한다.
- 리포트 : 환자의 수술과 관련된 상담 내용을 기록한 본문이다.
- 우편물 : 특정 주소로 발송되는 텍스트 문서다.
- 이미지 : 치아와 잇몸 엑스레이 사진을 저장한다. 용량이 크다.

## 설계 작업
테스트 주도 개발(TDD)은 프로그램을 시작하는 아주 좋은 방법 중 하나이다. 문서 관리 시스템은 필요에 따라 문서를 임포트해 내부 문서 저장소에 추가한다. 두 메서드를 포함하는 DocumentManagementSystem 클래스를 만들어 이 요구 사항을 구현한다.
- void importFile(String path) 
사용자가 문서 관리 시스템으로 임포트하려는 파일의 경로를 받는다. 제품 시스템의 사용자의 입력을 받는 공개 API이므로 java.nio.Path나 java.io.File 같이 더 안전한 형식을 지원하는 클래스 대신 평범한 String을 사용한다.
- List<Document> contents()
문서 관리 시스템에 저장된 모든 문서의 목록을 반환한다.
contents()는 Document 클래스 목록을 반환한다는 점을 알 수 있다.

### 임포터
다양한 종류의 문서를 임포트하는 것이 문서 관리 시스템의 핵심 기능이다.
파일의 확장자로 파일을 어떻게 임포트할지 결정할 수 있다.

```
switch(extension) {
    case "letter":
        // 우편물 임포트 코드
        break;

    case "report:
        // 레포트 임포트 코드
        break;
    
    case "jpg":
        // 이미지 임포트 코드
        break;
    
    default:
        throw new UnKnownFileTypeException("For file: " + path);
}
```

위 코드로 문제를 해결할 수 있지만 확장성은 부족하다. 다른 종류의 파일을 추가할 때마다 switch문에 다른 항목을 추가해 구현해야 하기 때문이다. 

메인 클래스를 깔끔하고 단순하게 유지하기 위해 다양한 문서를 임포트하는 클래스로 분리하면, 각각의 임포트 동작을 따로 처리하므로 찾기 쉽고, 이해하기 쉬운 코드를 만들 수 있다. 다양한 종류의 문서 임포트를 지원하도록 먼저 Importer 인터페이스를 정의한다. Importer 인터페이스를 구현하는 각 클래스는 다양한 종류의 파일을 임포트한다.

String 대신 파일을 가리키는 전용 형식을 이용하므로 오류가 발생할 범위를 줄인다. 이 원칙을 적용하기 위해 Importer 인터페이스의 파라미터로 java.io.File 객체를 사용해 임포트하는 파일을 가리킨다.

```
interface Importer {
    Document importFile(File file) throws IOException;
}
```


### Document 클래스
각 문서는 검색할 수 있는 다양한 속성을 포함한다. 문서의 종류에 따라 포함하는 속성이 달라진다. 다양한 방법으로 Document를 정의할 수 있지만 각각 장단점이 있다.
응용프로그램에 직접 Map<String, String>을 사용하지 않는 이유가 뭘까? 한 문서를 모델링하려고 새 도메인 클래스를 소개하는 것은 식은 죽 먹기처럼 간단히 결정할 수 있는 일이 아니라 응용프로그램의 유지보수성과 가독성을 고려해야 하는 일이다.

훌륭한 소프트웨어 개발팀은 유비쿼터스 언어로 자신의 소프트웨어를 작성한다. 
동료나 고객과 대화할 때 소프트웨어의 다양한 기능을 어떤 공통 언어로 약속한다. 이때 사용한 어휘를 코드로 매핑하면 코드의 어떤 부분을 바꿔야 하는지 쉽게 알 수 있다. 이를 발견성이라 한다.

> 유비쿼터스 언어는 에릭 에번스가 집필한 도메인 주도 설계에서 처음 등장했다. 유비쿼터스 언어란 개발자와 사용자 모두가 사용할 수 있도록 설계, 공유된 공통 언어를 말한다.

강한 형식을 이용하면 데이터의 사용 방법을 규제할 수 있다. 예를 들어 Document 클래스는 불변 클래스, 즉 클래스를 생성한 다음에는 클래스의 속성을 바꿀 수 없다. Import 구현이 문서를 만들면 이후에 수정할 수 없다. 따라서 Documen의 속성에서 오류가 발생하면 해당 Document를 생성한 Importer구현을 확인하면 되므로 오류가 발생한 원인을 좁힐 수 있다. Document의 불변성 덕분에 안전하게 Document로 색인을 만들거나 Document정보를 캐시할 수 있다.

Document가 HashMap<String, String>을 상속받도록 설계를 결정한 개발자도 있을 것이다. 이런 설계 방법에는 몇 가지 문제가 있다.
소프트웨어를 설계할 때 필요한 기능은 추가하면서 동시에 불필요한 기능은 제한해야 한다.
Document 클래스가 HashMap을 상속하면서 응용프로그램이 Document 클래스를 바꿀 수 있도록 결정한다면 이전에 불변성으로 얻을 수 있는 모든 이득이 단번에 사라진다. 컬렉션으로 감싸면 get() 등의 메서드(아무 의미를 포함하지 않는 메서드명)로 속성을 검색하지 않고 의미를 갖는 메서드 이름을 사용할 수 있다.
요약하자면 도메인 클래스를 이용하면 개념에 이름을 붙이고 수행할 수 있는 동작과 값을 제한하므로 발견성을 개선하고 버그 발생 범위를 줄일 수 있다.

```
public class Document {
    private final Map<String, String> attributes;

    Document(final Map<String, String> attributes) {
        this.attributes = attributes;
    }

    public String getAttribute(final String attributeName) {
        return attributes.get(attributeName);
    }
}
```
보통 자바 클래스의 생성자는 public을 사용하지만 그러면 프로젝트의 어디에서나 그 형식의 객체를 만들 수 있는 문제가 생긴다. 오직 문서 관리 시스템에서만 Document를 만들 수 있어야 하므로 패키지 영역으로 생성자를 제공하고, 문서 관리 시스템이 위치한 패키지에만 접근 권한을 준다.

### Document 속성 및 계층
응용프로그램에서 String으로 정보를 전달하는 것은 보통 좋지 않은 방법으로 알려져 있다. 이를 강한 형식에 빗대어 문자화 형식이라 부른다.
특히 속성ㄱ밧을 복잡하게 사용할 때는 다양한 속성 형식으로 파싱하는 것이 좋다. 
Importer의 구성 계층을 그대로 Document 클래스 계층에 사용할 수 있다. 예를 들어 ReporterImporter는 Reporter 클래스(Reporter는 Document 클래스 상속)의 인스턴스를 임포트한다. 이렇게 하면 상속으로 기본적인 무결성 검사를 대신할 수 있다.

문서의 각 서브클래스가 전용 필드를 갖지 않도록 모든 알려진 속성을 범용으로 설계했다. 또한 각 문서는 자신과 관련된 동작을 거의 포함하지 않는다. 클래스 계층으로 인한 이득이 없다면 계층을 추가할 필요가 없다.

## 리스코프 치환 원칙(LSP)
리스코프 치환 원칙은 클래스 상속과 인터페이스 구현을 올바르게 사용하도록 도와준다.
### 하위형식에서 선행조건을 더할 수 없음
선행조건은 어떤 코드가 동작하는 조건을 결정한다. 
LSP란 부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없음을 의미한다. 예를 들어 부모가 문서의 크기를 제한하지 않았다면, 문서의 크기가 100KB보다 작아야 한다고 요구할 수 없다.

### 하위형식에서 후행조건을 약화시킬 수 없음
후행조건은 어떤 코드를 실행한 다음에 만족해야하는 규칙이다. 예를 들어 유효한 파일에 improtFile()을 실행했다면 contents()가 반환하는 문서 목록에 그 파일이 반드시 포함되어야 한다.
즉 부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 그래야 한다.

### 슈퍼형식의 불변자는 하위형식에서 보존됨
불변자란 항상 변하지 않는 어떤 것을 가리킨다. 상속 관계의 부모와 자식 클래스가 있을 때, 부모 클래스에서 유지되는 모든 불변자는 자식클래스에서도 유지되어야 한다.

### 히스토리 규칙
기본적으로 자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않아야 한다. 예제의 Document는 바꿀 수 없는 불변 클래스다. 즉 Document 클래스를 인스턴스화한 다음에는 어떤 속성도 삭제, 추가, 변경할 수 없다. 모든 부모 클래스의 사용자는 Document 클래스의 메서드를 호출했을 때 어떤 일이 일어날 수 있음을 인지하고 있기 때문이다. 만약 자식이 불변이 아니라면 호출자의 예상을 뒤엎을 것이다.

### 임포터를 클래스로 만들기
인터페이스와 클래스는 서로 다른 기능을 제공한다. 인터페이스는 여러 개를 한 번에 구현할 수 있는 반면, 클래스는 일반 인스턴스 필드와 메서드를 갖는다.
다양한 임포트를 사용하도록 계층을 만든다. 쉽게 망가질 수 있는 상속 기반의 클래스를 피해야 한다고 설명했듯이 인터페이스를 이용하는 것이 클래스를 이용하는 것 보다 명백하게 좋은 선택이다.
모든 상황에서 클래스보다 인터페이스가 좋다는 이야기가 아니다. 문제를 해결하려는 도메인에 상태와 많은 동작이 관련되어 있어서 강력한 is a 관계를 모델링해야 하는 상황이라면 클래스 기반의 상속이 더 적절하다.

### 영역, 캡슐화 선택하기
같은 패키 안의 클래스만 패키지 영역의 클래스를 보거나 접근할 수 있으며 패키지 밖에서는 보거나 접근할 수 없다.
구현 중인 패키지의 세부 정보를 외부로 노출했다면 리팩터링이 어려워진다. 클래스가 외부로 노출되지 않도록 패키지 영역을 적극적으로 적용하면 내부 설계를 쉽게 바꿀 수 있다.

## 기존 코드 확장과 재사용
코드를 재사용 하려면 먼저 이코드를 어떤 클래스에 구현해야 한다. 다음과 같은 세가지 방법 중 하나를 선택할 수 있는데, 각각의 장단점이 있다.

### 유틸리티 클래스 사용
가장 간단한 방법은 유틸리티 클래스를 만드는 것이다. 유틸리티 클래스는 결국 여러 정적 메서드를 포함한다.
유틸리티 클래스는 객체지향 프로그래밍의 지향점과는 거리가 멀다. 객체 지향에서는 클래스로 기능을 만든다. 인스턴스를 만들고 싶다면 무조건 new Thing()을 호출한다. 
실제 객체를 클래스로 만드는 원칙을 따르면 도메인의 정신적 모델을 코드로 구조화하고 매핑시킬 수 있어 쉽게 이해할 수 있는 응용프로그램을 만들 수 있다.
유틸리티 클래스는 이런 예상을 뒤엎으며 보통 어떤 한 의무나 개념과 상관없는 다양한 코드의 모음으로 귀결된다.

### 상속 사용
상속을 사용하면 동작과 개념을 연결할 수 있다.
상속은 다양한 환경에서 사용할 수 있는 완벽히 든든한 지원군이다. 실제 관계를 상속으로 잘못 설정하는 상황도 종종 발생한다.
살제 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있다. 시간이 흐르고 응용프로그램이 바뀔 대, 응용 프로그램을 그에 맞게 바꾸는 것보다는 변화를 추상화하는 것이 더 좋다. 일반적으로 상속 관계로 코드를 재사용하는 것은 좋은 방법이 아니다.

### 도메인 클래스 사용
기본 개념을 모델링한 다음, 기본 개념이 제공하는 메서드를 호출해 다양한 임포터를 만든다. 여기서 기본 개념은 새롭거나 창의적이지 않다는 점이 핵심이다. 클래스 이름이 매우 단순 명료해 텍스트 파일을 조작하는 함수를 어디에 추가할지 쉽게 알 수 있다.

## 테스트 위생
자동화된 테스트를 구현하면 소프트웨어 유지보수에 큰 도움이 된다. 자동화된 테스트는 퇴행이 발생하는 범위를 줄이며 어떤 동작이 문제를 일으켰는지 이해할 수 있도록 도와준다.
테스트 유지보수 문제를 해결하려면 테스트 위생을 지켜야 한다. 테스트 위생이란 테스트 대상 코드 베이스뿐 아니라 테스트 코드도 깔끔하게 유지하며 유지보수하고 개선해야 함을 의미한다. 테스트를 유지보수하지 않고 방치 하면 시간이 지나면서 개발자의 생산성에 부담만 더해진다.

### 테스트 이름 짓기
테스트 이름을 짓기 전에 아주 명확하고 좋은 이름을 발견하는 상황은 흔치 ㅇ낳은 반면, 나쁜 이름 찾기는 더 쉽다.
테스트 이름을 지을 때 가독성, 유지보수성, 실행할 수 있는 문서의 역할을 고려한다. 테스트클래스가 실행 중인 리포트를 봤을 때 이름만으로 어떤 기능이 동작하고 어떤 기능이 동작하지 않았는지 알 수 있어야 한다. 

테스트 이름을 짓는 규칙
- 도메인 용어 사용 :: 문제 도메인을 설명하거나 응용프로그램에서 문제를 지칭할 때 사용하는 용어를 테스트 이름에 사용한다.
- 자연어 사용 :: 모든 테스트 이름은 일반 문장처럼 쉽게 읽을 수 있어야 한다. 테스트 이름은 항상 어떤 동작을 쉽게 이해할 수 있도록 묘사해야 한다.
- 서술적 :: 코드는 한 번 구현하면 여러 번 읽게 된다. 나중에 쉽게 읽을 수 있도록 애초에 시간을 들여 서술적인 좋은 이름을 붙이자. 좋은 이름이 생각나지 않으면 동료에게 도움을 받자. 골프는 타수가 적은 사람이 승자다. 하지만 프로그래밍은 다르다. 짧다고 다 좋은 것은 아니다.

### 구현이 아닌 동작
클래스, 컴포넌트, 시스템 테스트를 구현할 때는 대상의 공개 동작만 테스트한다.
테스트는 객체의 내부 상태나 설계는 고려하지 않고 오직 공개 API 메서드만 이용해 테스트를 수행해야 한다. 이를 지키지 않아 유지보수하기 어려운 테스트를 만드는 실수는 개발자들이 종종 저지르는 실수다. 세부 구현에 의존한 테스트는 구현이 바뀌면(심지어 동작은 그대로일지라도) 결과가 실패로 바뀐다.
쉽게 테스트하기 위해 상태를 노출하면, 장기적 관점에서 응용프로그램을 유지보수하기가 어렵다. 코드베이스를 바꾸면 테스트에도 영향을 미치기 때문이다. 이는 조금 더 쉽고 효과적으로 테스트할 수 있도록 새 클래스를 만드는 리팩터링이 필요하다는 신호일 수 있다.

### 중복 배제
많은 개발자가 응용프로그램 코드에는 중복 코드를 사용하지 않으려 애쓰지만, 테스트 코드의 중복 코드는 크게 신경쓰지 않는다.

### 좋은 진단
테스트는 실패하지 않으면 소용이 없다. 테스트가 실패하지 않으면 테스트가 동작하는지 알 수 없기 때문이다. 실패에 최적화된 테스트를 구현하는 것이 좋다. 여기서 말하는 최적화란 실패했을 때 테스트를 더 빨리 실행할 수 있도록 만든다는 의미가 아니다. 테스트가 실패한 이유를 쉽게 이해할 수 있도록 만들어야 한다는 의미다. 이때 좋은 진단을 활용한다.

진단이란 테스트가 실패했을 때 출력하는 메시지와 정보를 의미한다. 실패한 이유를 설명하는 메시지가 명확해야 쉽게 디버깅할 수 있다.

Matcher는 값이 어떤 속성과 일치하는지와 관련 진단을 캡슐화한다. hasSize() 매처는 Matchers 유틸리티 클래스 (다양한 매처를 포함하는 번들)에서 정적으로 임포트한 메서드로 컬렉션의 크기가 파라미터의 값과 일치하는지 확인한다. 

### 오류 상황 테스트
테스트를 개발하면서 가장 흔히 저지르는 실수 중 하나는 응용프로그램의 가장 아름답고, 중요하며, 잘 동작하도록 예상된 경로만 검증하는 것이다.

제이유닛 @Test 애너테이션의 expected = 속성을 사용해 원하는 어서션을 추가한다. 이 애너테이션은 '이 테스트는 이런 종류의 예외를 던질 것이다'라는 의미를 전달한다.

```
@Test(expected = FileNotFoundException.class)
public void shoulNotImportMissingFile() throws Exception
```

### 상수
상수에도 테스트에 활용되는 용도에 따라 적절한 이름을 붙이는 것이 좋다.