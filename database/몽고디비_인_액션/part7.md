## 도큐먼트 업데이트
### 대치에 의한 수정
```
user_id = ObjectId("4c4b1231515")
doc = db.users.findOne({_id: user_id})
doc['email'] = 'mongodb-user@mongodb.com'
print('updating ' + user_id)
db.users.update({_id: user_id}, doc)
```

### 연산자에 의한 수정
```
user_id = ObjectId("4c4b1231515")
db.users.update({_id: user_id}, {$set: {email: 'mongodb-user2@mongodb.com'}})
```

### 결정:대치 vs 연산자
대치에 의한 수정은 좀 더 일반적인 방식이다. 사용자의 어떤 속성을 수정하든지 상관없이 업데이트를 수행하는 코드는 동일하다.

타깃 방식의 수정은 좀 더 나은 성능을 갖는다. 먼저, 수정할 도큐먼트를 가져오기 위해 서버에 도큐먼트 요청을 할 필요가 없다. 업데이트를 지정하는 도큐먼트의 크기가 일반적으로 작다.

타깃 방식은 도큐먼트를 원자적으로 업데이트하는 데 적합하다.

대치 방식의 업데이트는 일관성을 깨뜨릴 수 있다. 예를 들어, 한 사용자가 자신이 작성한 리뷰의 내용을 수정하려고 하는데 이 업데이트가 대치 방식으로 이루어진다고 가정해 보자. 대치 방식으로 업데이트를 할 때 수정하려는 도큐먼트에 대한 질의를 먼저 해야 한다. 하지만 리뷰에 대한 질의를 하고 난 후 대치를 하기 전에 또 다른 사용자가 이 리뷰를 추천할 수 있다. 이를 **레이스 컨디션(race condition)**이라 한다.

### 동시성, 원자성 고립
MongoDB에서 동시성(concurrency)이 어떻게 수행되는지 이해하는 것이 중요하다. MongoDB v2.2 이전까지는 잠금(locking) 전략이 상당히 정교하지 못했다. 하나의 글로벌 읽기-쓰기 잠금이 mongod 인스턴스 전체를 관장한다. 이것이 뜻하는 바는 어느 한 시점에서 데이터베이스는 하나의 쓰기 혹은 다수의 읽기를 허용하지만 둘 다 허용하지는 않는다는 것이다.

MongoDB v2.2에서 이는 데이터베이스 레벨 잠금으로 변경되었는데, 이는 이러한 잠금 전략이 MongoDB 인스턴스 전체가 아니라 데이터베이스 레벨에 적용된다는 것을 뜻한다. 데이터베이스는 하나의 쓰기 또는 여러 개의 읽기를 가질 수 있다. MongoDB v3.0에서 WiredTriger 스토리지 엔진은 컬렉션 레벨에서 작동하며, 도큐먼트 수준의 잠금 기능을 제공한다. 다른 스토리지 엔진은 다른 특성을 제공할 수 있을 것이다.

잠금 기능은 상당히 많은 동시성 최적화가 존재하므로 실제보다 훨씬 더 좋지 않게 들릴 수 있다. 하나는 랩에 있는 도큐먼트의 내부 맵을 데이터베이스가 유지한다는 것이다. 램에 있지 않은 도큐먼트를 읽거나 쓰려는 오쳥의 경우 도큐먼트가 메모리로 페이징될 때까지 다른 작업을 수행한다.

두 번재 최적화는 쓰기 잠금을 양보하는 것이다. 쓰기 연산의 시간이 오래 걸리면 다른 모든 읽기와 쓰기 연산은 원래의 쓰기가 완료될 때까지 블록된다. 모든 삽입, 업데이트, 삭제 연산은 쓰기 잠금을 수행한다. 삽입 연산은 시간이 오래 걸리는 경우가 거의 없다. 하지만 업데이트나 삭제의 경우 전체 컬렉션에 영향을 미치는 경우에는 오랫동안 실행될 수 있다. 이문제 대한 현재의 해결책은 오랜 시간이 소요되는 연산을 주기적으로 다른 읽기와 쓰기에게 양보하는 것이다. 연산을 양보할 때 잠시 연산을 멈추고 잠금을 해제했다가 나중에 연산을 재개한다.

이러한 최적화에도 불구하고 MongoDB의 잠금은 읽기가 많고 쓰기가 많은 작업 부하의 성능에 영향을 미칠 수 있다. 문제를 피하는 좋은 방법은, 특히 MMAPv1 스토리지 엔진을 사용하는 경우 트래픽이 대량으로  발생하는 컬렉션을 별도의 데이터베이스에 저장하는 것이다. 그러나 앞서 언급했듯이 MongoDB v3.0은 WiredTiger가 데이터베이스 레벨이 아닌 컬렉션 레벨에서 작동하므로 이런 상황에서는 훨씬 좋은 편이다.

