# 입출금 내역 분석기 확장판
## 확장된 입출금 내역 분석기 요구 사항
1. 특정 입출금 내역을 검색할 수 있는 기능, 예를 들어 주어진 날짜 범위 또는 특정 범주의 입출금 내역 얻기.
2. 검색 결과의 요약 통계를 테스트, HTML등 다양한 형식으로 만들기

## 개방/폐쇄 원칙
- 거래 내역의 여러 속성을 조합할수록 코드가 점점 복잡해진다.
- 반복 로직과 비즈니스 로직이 결합되어 분리하기가 어려워진다.
- 코드를 반복한다.

개방/폐쇄 원칙을 적용하면 코드를 직접 바꾸지 않고 해당 메서드나 클래스의 동작을 바꿀 수 있다. 
현재 코드에는 반복 로직과 비즈니스 로직이 결합되어 있다. 비즈니스 로직을 담당하는 BankTransactionFilter 인터페이스를 만들어 문제를 해결한다. 

```
@FunctionalInterface
public interface BankTransactionFilter {
    boolean test(BankTransaction bankTrasaction);
}
```
BankTransactionFilter 인터페이스는 BankTransaction의 선택 조건을 결정한다. 
findTransactions()메서드는 더 이상 특정 필터 구현에 의존하지 않는다. 기존 메서드의 바디를 바꿀 필요 없이 새로운 구현을 인수로 전달하기 때문이다. 따라서 변경 없이도 확장성은 개방된다. 이런 방식으로 기능을 확장하면 기존에 이미 구현하고 검증한 코드를 바꾸는 일을 최소화할 수 있으므로 새로운 버그가 발생할 만한 대상을 줄일 수 있다. 예전 코드를 바꾸지 않고도 새로운 기능을 추가할 수 있기 때문이다.

개방/폐쇄 원칙의 장점
- 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
- 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
- 결합도가 낮아지므로 코드 유지보수성이 좋아진다.

## 인터페이스 문제
한 인터페이스에 모든 기능을 추가하는 갓 인터페이스를 만드는 일은 피해야 한다.

### 갓 인터페이스
- 자바의 인터페이스는 모든 구현이 지켜야 할 규칙을 정의한다. 즉 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야 한다. 따라서 인터페이스를 바꾸면 이를 구현한 코드도 바뀐 내용을 지원하도록 갱신되어야 한다. 더 많은 연산을 추가할수록 더 자주 코드가 바뀌며, 문제가 발생할 수 있는 범위도 넓어진다.
- 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제가 생겼다. 도메인 객체의 세부 내용이 바뀌면 인터페이스도 바뀌어야 하며 결과적으로 구현 코드도 바뀌어야 한다.

### 지나친 세밀함
기능이 여러 인터페이스로 분산되면 필요한 기능을 찾기 어렵다. 자주 사용하는 기능을 쉽게 찾을 수 있어야 유지보수성도 좋아진다. 더욱이 인터페이스가 너무 세밀하면 복잡도가 높아지며, 새로운 인터페이스가 계속해서 프로젝트에 추가된다.

## 명시적 API vs 암묵적 API
### 도메인 클래스 vs 원시값
원싯값으로는 다양한 결과를 반환할 수 없어 유연성이 떨어진다. 원싯값을 감싸는 새 도메인 클래스를 만들면 문제를 해결할 수 있다.
이렇게 하면 도메인의 다양한 개념간의 결합을 줄이고, 요구 사항이 바뀔 때 연쇄적으로 코드가 바뀌는 일도 최소화할 수 있다.

## 예외 처리
### 예외를 사용해야 하는 이유
자바는 예외를 일급 언어 기능으로 추가하고 다음과 같은 장점을 제공한다.
- 문서화 : 메서드 시그니처 자체에 예외를 지원한다.
- 형식 안전성: 개발자가 예외 흐름을 처리하고 있는지를 형식 시스템이 파악한다.
- 관심사 분리: 비즈니스 로직과 예외 회복이 각각 try/catch 블록으로 구분된다.
다만 예외 기능으로 복잡성이 증가한다는 단점이 생긴다.
자바는 두가지 종류의 예외를 지원한다.
- 확인된 예외: 회복해야 하는 대상의 예외다. 자바에서는 메서드가 던질 수 있는 확인된 예외 목록을 선언해야 한다. 아니면 해당 예외를 try/catch로 처리해야 한다.
- 미확인 예외: 프로그램을 실행하면서 언제든 발생할 수 있는 종류의 예외다. 확인된 예외와 달리 메서드 시그니처에 명시적으로 오류를 선언하지 않으면 호출자도 이를 꼭 처리할 필요가 없다.

Error와 RuntimeException클래스는 미확인 예외이며 Throwable의 서브 클래스다. 보통 이런 오류는 잡지 않는다. Exception 클래스는 일반적으로 프로그램에서 잡아 회복해야 하는 오류를 가리킨다.

### 예외의 패턴과 안티 패턴
**미확인 예외와 확인된 예외에서 선택하기**
일시적으로 발생하는 오류라면 동작을 다시 시도하거나 화면에 메시지를 출력해 응용프로그램의 반응성을 유지할 수 있다. 보통 비즈니스 로직 검증(잘못된 형식이나 연산 등) 시 발생한 문제는 불필요한 try/catch 구문을 줄일 수 있도록 미확인 예외로 결정한다. 또한 예외가 발생했을 때 응용프로그램을 어떻게 회복 시킬 것인지 애매한 상황도 있다. 이런 상황에서는 API사용자에게 오류를 복구하라고 강제할 필요가 없다. 
시스템 오류(저장 공간이 꽉 참)가 발생했을 때 사용자가 할 수 있는 일이 없으므로 시스템 오류도 미확인 예외로 지정한다.
즉, 대다수의 예외를 미확인 예외로 지정하고 꼭 필요한 상황에서만 확인된 예외로 지정해 불필요한 코드를 줄여야 한다.
**과도하게 세밀함**
다음과 같은 이유로 전용 Validator 클래스를 만드는 것을 권한다.
- 검증 로직을 재사용해 코드를 중복하지 않는다.
- 시스템의 다른 부분도 같은 방법으로 검증할 수 있다.
- 로직을 독립적으로 유닛 테스트할 수 있다.
- 이 기법은 프로그램 유지보수와 이해가 쉬운 SRP를 따른다.
세밀하게 예외를 처리하면 각각의 예외에 적합하고 정확한 회복 기법을 구현할 수 있지만 너무 많은 설정 작업이 필요하고, 여러 예외를 선언해야 하며, 사용자가 이 모든 예외를 처리해야 하므로 생산성이 현저하게 떨어진다.

**과도하게 덤덤함**
과한 세밀함과는 정반대로 모든 예외를 IllegalArgumentException 등의 미확인 예외로 지정하는 극단적인 상황도 있다. 전부 동일한 예외로 지정하면 구체적인 회복 로직을 만들 수 없는 문제가 생긴다. 마찬가지로 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다.

**노티피케이션 패턴**
노티피케이션 패턴은 너무 많은 미확ㅇ니 예외를 사용하는 상황에 적합한 해결책을 제공한다.

```
public Notification validate() {
    final Notification notification = new Notification();
    if(this.description.length() > 100) {
        notification.addError("The description is too long");
    }

    try {
        parsedate = LocalDate.parse(this.date);
        if(parsedDate.isAfter(LocaDate.now())) {
            notification.addError("date cannot be in the future");
        }
    } catch(DateTimeParseException e) {
        notification.addError("Invalid format for date");
    }

    return notification
}
```
### 예외 사용 가이드 라인
**예외를 무시하지 않음**
문제의 근본 원인을 알 수 없다고 예외를 무시하면 안 된다. 예외를 처리할 수 있는 방법이 명확하지 않으면 미확인 예외를 대신 던진다. 이렇게 하면 확인된 예외를 정말로 처리해야 할 때 런타임에서 어떤 문제가 발생하는지 먼저 확인한 다음, 이전 문제로 돌아와 필요한 작업을 다시 시작할 수 있다.

**일반적인 예외는 잡지 않음**
가능한 구체적으로 예외를 잡으면 가독성이 높아지고 더 세밀하게 예외를 처리할 수 있다. 일반적인 Exception은 RuntimeException도 포함한다.

**예외 문서화**
API 수준에서 미확인 예외를 포함한 예외를 문서화하므로 API사용자에게 문제 해결의 실마리를 제공한다. 사실 미확인 예외 보고서는 해결해야 할 문제의 원인을 포함한다.

**특정 구현에 종속된 예외를 주의할 것**
특정 구현에 종속된 예외를 던지면 API의 캡슐화가 깨지므로 주의하자.

**예외 vs 제어흐름**
예외로 흐름을 제어하지 않는다.
예외를 처리하느라 불필요한 try/catch 문법이 추가되어 코드 가독성을 떨어트린다. 또한 코드의 의도도 이해하기 어려워진다. 예외는 오류와 예외적인 시나리오를 처리하는 기능이기 때문이다. 결론적으로 예외를 정말 던져야 하는 상황이 아니라면 예외를 만들지 않아야 한다. 마지막으로 예외가 발생했을 때 스택 트레이스 생성, 보존과 관련된 부담이 생긴다.

### 예외 대안 기능
**null 사용**
예외를 던지지 않고 null을 반환하는 방법은 절대 사용하지 않아야 한다. 사실상 null은 호출자에게 아무 정보도 제공하지 않는다. API의 결과가 null인지 항상 확인해야 하므로 오류가 쉽게 발생할 수 있다.

**null 객체 패턴**
자바에서는 종종 null 객체 패턴을 사용한다. 객체가 존재하지 않을 때 null 레퍼런스를 반환하는 대신에 필요한 인터페이스를 구현하는 객체(바디는 비어 있음)를 반환하는 기법이다. 
의도하지 않은 NullPointException과 긴 null확인 코드를 피할 수 있다.
이 패턴을 사용하면 데이터에 문제가 있어도 빈 객체를 이용해 실제 문제를 무시할 수 있어 나중에 문제를 해결하기가 더 어려워질 수 있다.

**Optional<T>**
Optional<T>는 값이 없는 상태를 명시적으로 처리하는 다양한 메서드 집합을 제공하므로 버그의 범위를 줄이는데 큰 도움이 된다. 또한 다양한 Optional 객체를 조합할 수 있어 다른 API에서 반환한 Optional형식을 다른 Optional형식과 조합할 수 있다.

**Try<T>**
성공하거나 실패할 수 있는 연산을 가리킨다. Optional<T>와 비슷하지만 값이 아니라 연산에 적용한다는 점이 다르다. 즉 Try<T> 데이터 형식도 코드 조합성의 장점을 제공하며 코드에서 발생하는 오류 범위를 줄여준다. JDK는 Try<T>를 제원하지 않는다.

## 빌드 도구 사용
### 왜 빌드 도구를 사용할까?
빌드 도구는 응용프로그램 빌드, 테스트, 배포 등 소프트웨어 개발 생명주기를 자동화할 수 있도록 도와준다. 빌드 도구는 다음과 같은 다양한 장점을 제공한다.
- 프로젝트에 적용되는 공통적인 구조를 제공하기 때문에 동료 개발자가 프로젝트를 좀 더 편안하게 받아들인다.
- 응용프로그램을 빌드하고 실행하는 반복적이고, 표준적인 작업을 설정한다.
- 저수준 설정과 초기화에 들이는 시간을 절약하므로 개발에만 집중할 수 있다.
- 잘못된 설정이나 일부 빌드 과정 생략등으로 발생하는 오류의 범위를 줄인다.
- 공통 빌드 작업을 재 사용해 이를 다시 구현할 필요가 없으므로 시간을 절약한다.
