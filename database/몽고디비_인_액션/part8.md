### 인덱스 효율
어떤 컬렉션에 도큐먼트를 추가할 때마다 그 컬렉션에 대해 생성된 인덱스도 그 새로운 도큐먼트를 포함시키도록 수정해야 한다.

읽기 위주의 애플리케이션에서 인덱스 비용은 인덱스로 인해 얻을 수 있는 효과로 상쇄된다. 인덱스에는 비용이 발생하니 조심해서 생성해야 한다. 

두 번째로 고려해야 할 사항은 필요한 모든 인덱스가 적합하게 만들어졌다고 해도 쿼리를 더 빠르게 처리하지 못할 가능성이 여전히 존재한다는 점이다. 이것은 인덱스와 현재 작업 중인 데이터를 램에서 다 처리하지 못할 때 발생한다.

WiredTiger 스토리지 엔진은 다르게 작동한다. 이 시점부터는 모든 도큐먼트, 컬렉션, 인덱스를 포함하는 데이터 파일이 페이지(page)라고 부르는 4KB의 청크로 운영체제에 의해 램으로 스왑된다. 해당 페이지에 대한 데이터가 요청될 때마다 OS는 그 페이지가 램에 있는지 확인해야 한다. 만약 램에 없으면 페이지 폴트(page fault) 예외를 발생시키고, 메모리 관리자는 해당 페이지를 디스크로부터 램으로 불러들인다.

램이 충분하다면 사용하는 모든 데이터 파일이 메모리에 로드될 것이다. 쓰기 연산에서와 같이 메모리의 데이터가 수정될 경우에 이러한 수정사항은 OS에 의해 비동기적으로 디스크에 반영된다. 하지만 쓰기 연산은 빠르고 램에서 직접 발생하므로 디스크 액세스 횟수가 최소화 된다.

그러나 모든 데이터를 수용하지 못하면 점점 페이지 폴트가 발생하기 시작한다. 이것은 OS가 디스크를 빈번하게 액세스함으로써 읽기와 쓰기 연산이 매우 느려지게 된다는 것을 뜻한다. 최악의 경우에는 데이터의 크기가 가용한 램의 크기보다 훨씬 더 커서 모든 읽기와 쓰기에 대해 디스크 액세스를 해야 하는 상황이 발생할 수도 있다. 이런 현상을 스래싱(ghrashing)이라고 하는데, 성능을 심각하게 저해한다.

인덱스를 추가로 만들면 인덱스를 유지하기 위해 더 많은 램이 필요하다. 같은 논리로 각 인덱스는 필요한 키만 가지고 있어야 한다.

### B-트리
MongoDB는 내부적으로 B-트리로 인덱스를 생성한다. 
MongoDB에서 구현된 B-트리는 새 노드에 대해 8,192바이트가 할당되는데, 이것은 각 노드가 실제적으로 수백 개의 키를 가질 수 있다는 것을 뜻한다. 이것은 물론 인덱스 키의 평균 크기에 따라 달라질 수 있다.
한 가지 주목해야 할 사항은 각 노드는 고정된 빈 공간을 가지고 있다는 것이다.