복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미다. 데이터 복제가 필요한 여러 이유가 있다.
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 직속적으로 동작할 수 있게 해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

복제중인 데이터가 시간이 지나도 변경되지 않는다면 복제는 쉽다. 한번에 모든 노드에 데이터를 복사하면 된다. 복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있다. 노드 간 변경을 복제하기 위한 세 가지 인기 있는 알고리즘인 단일 리더, 다중 리더, 리더없는 복제를 살펴본다. 거의 모든 분산 데이터베이스는 이 세 가지 방법 중 하나를 사용한다. 이러한 알고리즘에는 다양한 장단점이 있다.

## 리더와 팔로워
데이터베이스의 복사본을 저장하는 각 노드를 복제 서버(replica)라고 한다. 다중 복제 서버를 사용하면 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할 수 있는지 궁금증이 생긴다.
데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리돼야 한다: 그렇지 않으면 복제 서버는 더이상 동일한 데이터를 유지할 수 없다. 이 문제를 위한 가장 일반적인 해걸책은 리더 기반 복제(leader-based replication)(또는 능동(active)/수동(passive), 마스터(master) 슬레이브(slave) 복제라고도 함)이다.
복제 서버 중 하나를 리더(leader)(마스터나 프라이머리(primary)라고도 함)로 지정한다. 클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내야 한다. 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다. 다른 복제 서버는 팔로워}(follower)(읽기 복제 서버(read replica), 슬레이브, 2차(secondary), 핫 대기(hot standby))라고 한다. 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그(replication log)나 변경 스트림(change stream)의 일부로 팔로워에게 전송한다. 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사본을 갱신한다.

클라이언트가 데이터베이스로 부터 읽기를 할 때는 리더 또는 임의 팔로워에게 질의할 수 있다. 하지만 쓰기는 리더에게만 허용된다.(팔로워는 클라이언트 관점에서는 읽기 전용이다).

### 동기식 대 비 동기식 복제
복제 시스템의 중요한 세부 사항은 복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부다.  
보통 복제는 매우 빠르다. 대부분의 데이터베이스 시스템은 1초 내에 팔로워에게 변경 내용을 적용하지만 얼마나 오래 걸릴지는 보장할 수 없다. 팔로워가 수분 이상 리더와 떨어질 수 있다. 팔로워가 장애를 복구 중이거나 시스템이 최대 가용량 부근에서 동작하거나 노드 간 네트워크 문제가 있을 수 있기 때문이다.

동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다. 갑자기 리더가 작동하지 않아도 데이터는 팔로워에서 계속 사용할 수 있음을 확신할 수 있다. 단점은 (팔로워가 죽거나 네트워크 문제나 다른 어떤 이유로 인해) 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다는 것이다. 리더는 모든 쓰기를 차단(block)하고 동기 복제 서버가 다시 사용할 수 있을 때까지 기다려야 한다.

이런 이유로 모든 팔로워가 동기식인 상황은 비현실적이다. 임의 한 노드의 장애는 전체 시스템을 멈추게 한다. 현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 것을 의미한다. 동기식 팔로워가 사용할 수 없게 되거나 느려지면 비동기식 팔로워 중 하나가 동기식이 된다. 이것은 적어도 두 노드(리더와 하나의 동기 팔로워)에 데이터의 최신 복사본이 있는 것을 보장한다. 이런 설정을 **반동기식(semi-synchronous)**이라 한다.

보통 리더 기반 복제는 완전히 비동기식으로 구성한다. 이런 경우 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다. 이것은 쓰기가 클라이언트에게 확인된 경우에도 지속성을 보장하지 않는다는 의미다. 하지만 완전 비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속할 수 있는 장점이 있다.

비동기식 복제는 내구성을 약화 시키기 때문에 나쁜 트레이드오프 같지만 그럼에도 특히 많은 팔로워가 있거나 지리적으로 분산됐다면 비독시기 복제를 널리 사용한다.

### 새로운 팔로워 설정
복제 서버 수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워를 설정할 때 새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장할까? 클라이언트는 지속적으로 데이터베이스에 기록하고 데이터는 항상 유동적이기 때문에 표준 파일 복사본은 다른 시점에 데이터베이스의 다른 부분을 보게 된다. 즉, 복사 결과가 유효하지 않을 수 있다.
데이터베이스를 잠가서(스기가 불가능하게 만듦) 디스크의 파일을 일관성 있게 만들 수 있지만 고가용성 목표에 부합하지 않는다. 다행히 팔로워 설정은 대개 중단시간 없이 수행할 수 있다.
1. 가능하다면 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져온다. 대부분의 데이터베이스는 백업이 필요하기 때문에 이 기능을 갖췄다.
2. 스냅숏을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다. 이것은 스냅숏이 리더의 복제 로그의 정확한 위치와 연관돼야 한다.
4. 팔로워가 스냅숏 이후 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 말한다. 이제부터 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

팔로워를 설정하는 실제 과정은 데이터베이스에 따라 크게 다르다. 일부 시스템은 설정 과정이 완전 자동화인 반면 운영자가 수동으로 수행해야 하는 약간 애매한 여러 단계의 워크플로가 있는 경우도 있다.

## 노드 중단 처리
시스템의 모든 노드는 장애로 인해 예기치 않게 중단될 수 있지만 계획된 유지보수(예를 들어 커널의 보안 패치 설치를 위한 장비 리부팅)로 인해 중단될 수도 있다. 리더 기반 복제에서 고가용성은 어떻게 달성할 수 있을까?

### 팔로워 장애: 따라잡기 복구
각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관한다. 팔로워가 죽어 재시작하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 팔로워는 매우 쉽게 복구할 수 있다. 먼저 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다. 그러면 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다. 이 변경이 다 적용되면 리더를 다 따라잡게 되고 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있다.

### 리더 장애: 장애 복구
리더에 장애가 발생하면 팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다. 이 과정을 장애 복구(failover)라 한다.

장애 복구는 수동으로 진행(관리자는 리더의 장애 알림을 받고 새로운 리더를 만들기 위해 필요한 조치를 취한다)하거나 자동으로 진행한다. 자동 장애 복구는 보통 다음과 같은 단계로 구성된다.
1. 리더가 장애인지 판단한다. 대부분의 시스템은 장애확인을 단순히 타임아웃을 사용한다. 노드들은 자주 서로 메시지를 주고 받으며 일정 시간 동안 노드가 응답하지 않으면(예를 들어 30초) 죽은것으로 간주한다. (리더가 계획된 유지보수를 위해 의도적으로 중단된 경우는 타임아웃을 적용하지 않는다.)
2. 새로운 리더를 선택한다. 이것은 선출 과정(리더가 나머지 복제 서버의 대다수에 의해 선택됨)을 통해 이뤄지거나 이전에 선출된 제어노드(controller node)에 의해 새로운 리더가 임명될 수 있다. 새로운 리더로 가장 적합한 후보는 보통 이전 리더의 최신 데이터 변경사항을 가진 복제 서버다.
3. 새로운 리더 사용을 위해 시스템을 재설정한다. 클라이언트는 이제 새로운 쓰기 요청을 새로운 리더에게 보내야 한다. 이전 리더가 돌아오면 여전히 자신이 리더라 믿을 수 있으며 다른 복제 서버들이 자신을 리더에서 물러나게 한 것을 알지 못한다. 시스템은 이전 리더가 팔로워가 되고 새로운 리더를 인식할 수 있게끔 해야 한다. 


장애 복구 과정은 잘못될 수 있는 것 투성이다.
- 비동기식 복제를 사용한다면 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있다. 새로운 리더가 선출된 다음 이전 리더가 클러스터에 다시 추가된다면 이 쓰기를 어떻게 해야 할까? 가장 일반적이 해결책은 이전 리더의 복제되지 않은 쓰기를 단순히 폐기하는 방법이다. 이 방법은 내구성에 대한 클라이언트의 기대를 저버리게 된다.
- 쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 특히 위험하다. 
- 특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있다. 이런 상황을 스플릿 브레인(split brain)이라 한다. 스플릿 브레인은 매우 위험한 상황이다. 두 리더가 쓰기를 받으면서 충돌을 해소하는 과정을 거치지 않으면 데이터가 유실되거나 오염된다. 일부 시스템에는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 메커니즘이 있다. 하지만 이 매커니즘을 주의깊게 설계하지 않으면 두 개의 노드가 모두 종료될 수 있다.
- 리더가 분명히 죽었다고 판단 가능한 적절한 타임아웃은 얼마일까? 긴 타임아웃은 리더가 작동하지 않을 때부터 복구까지 오랜 시간이 소요된다는 의미다. 하지만 타임아웃이 너무 짧으면 불필요한 장애 복구가 있을 수 있다. 

이 문제에 대한 쉬운 해결책은 없다. 이런 이유로 일부 운영팀은 소프트웨어가 자동장애 복구를 지원하더라도 수동 으로 장애 복구를 수행하는 방식을 선호한다.

## 복제 로그 구현
### 구문 기반 복제
리더는 모든 쓰기 요청(구문(statement))을 기록하고 쓰기를 실행한 다음 구문 로그를 팔루워에게 전송한다. 관계형 데이터베이스는 모든 INSERT, UPDATE, DELETE 구문을 팔로워에게 전달하고 각 팔로워는 클라이언트에서 직접 받은 것 처럼 SQL 구문을 파싱하고 실행한다.

이 접근법은 합리적인것 같지만 깨질 수 있는 다양한 사례가 있다.
- 현재 날짜와 시간을 얻기 위한 NOW()나 임의 숫자를 얻기 위한 RAND() 같은 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 가능성이 있다.
- 자동증가 칼럼을 사용하는 구문이나 데이터베이스에 있는 데이터에 의존한다면 구문은 각 복제 서버에서 정확히 같은 순서로 실행돼야 한다. 그렇지 않으면 효과가 달라질 수 있다. 이 방식은 동시에 여러 트랜잭션이 수행되는 것을 제한하게 된다.
- 부수 효과를 가진 구문(예: 트리거, 스토어드 프로시저, 사용자 정의 함수)은 부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있다.

### 쓰기 전 로그 배송
리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다. 팔로워가 이 로그를 처리하면 리더에서 있는 것과 정확히 동일한 데이터 구조의 복제복이 만들어진다.

이 복제 방식은 포스트그레스큐엘과 오라클 등에서 사용된다. 가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다. WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함한다. 이렇게 하면 복제가 저장소 엔진과 밀접하게 엮인다. 데이터베이스가 저장소 형식을 다른 버전으로 변경한다면 대개 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없다.

이 문제는 사소한 구현의 세부 사항처럼 보일 수 있지만 운영상 큰 영향을 미칠 수 있다. 팔로워가 리더보다 새로운 소프트웨어 버전을 사용하게끔 복제 프로토콜이 허용한다면 팔로워를 먼저 업그레이드함으로써 중단시간 없이 데이터베이스 소프트웨어 업그레이드 수행이 가능하다. 그러면 업그레이드된 노드 중 하나를 새로운 리더로 선정하기 위해 장애 복구를 수행할 수 있다. WAL 배송과 같이 복제 프로토콜이 버전의 불일치를 허용하지 않는다면 업그레이드할 때 중단시간이 필요하다.

### 논리적(로우 기반) 로그 복제
복제 로그를 저장소 엔진 내부와 분리하기 위한 대안 하나는 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것이다. 이 같은 종류의 복제 로그를 저장소 엔진의 (물리적) 데이터 표현과 구별하기 위해 논리적 로그(logical log)라고 부른다.

관계형 데이터베이스용 논리적 로그는 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다.
- 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.
- 삭제된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보를 포함한다. 보통 이것은 기본키지만 테이블에 기본키가 없다면 모든 칼럼의 예전 값을 로깅해야 한다.
- 갱신된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보와 모든 칼럼의 새로운 값(적어도 변경된 모든 컬럼의 새로운 값)을 포함한다.

여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다. (로우 기반 복제를 사용하게끔 설정한 경우) 마이 SQL의 이진 로그는 이 접근 방식을 사용한다.

논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있고 리더와 팔로워에서 다른 버전의 데이터베이스 소프트웨어나 심지어 다른 저장소 엔진을 실행할 수 있다.

또한 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉽다. 이런 측면은 오프라인 분석이나 사용자 정의 색인과 캐시 구축을 위해 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다. 이 기술을 변경 데이터 캡처(change data )라고 한다.

### 트리거 기반 복제
앞의 복제 접근 방식은 애플리케이션 코드의 사용 없이 데이터베이스 시스템에 의해 구현된다. 대부분 이 방식을 원하지만 조금 더 유연성이 필요한 몇 가지 상황이 있다. 예를 들어 데이터의 서브셋만 복제하거나 데이터베이스를 다른 종류의 데이터베이스로 복제해야 하거나 충돌 해소 로직이 필요하다면 복제를 애플리케이션 층으로 옮겨야 한다.
관계형 데이터베이스에서 사용할 수 있는 기능인 트리거나 스토어드 프로시저를 사용한다.

트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있개 한다. 이 애플리케이션 코드는 데이터 베이스 시스템에서 데이터가 변경되면(쓰기 트랜잭션) 자동으로 실행된다. 트리거는 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다. 이 테이블로부터 데이터 변경을 외부 프로세스가 읽을 수 있다. 그러면 외부 프로세스는 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제한다. 예를 들어 오라클용 데이터 버스와 프스트그레스큐엘용 부카르도가 이와같이 동작한다.

일반적으로 트리거 기반 복제에는 다른 복제방식보다 많은 오버헤드가 있다. 이 방식은 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생한다. 그럼에도 트리거 기반 복제는 유연성 때문에 매우 유용하다.

## 복제 지연 문제
노드 내결함성을 갖추려는 단 한 가지 이유는 복제가 필요하기 때문이다. 확장성(단일 장비에서 감당하지 못하는 요청을 처리)과 지연 시간(사용자에게 지리적으로 더 가까운 복제서버를 위치시킴)이 또 다른 이유다.

리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하지만 읽기 전용 질의는 어떤 복제 서버에서도 가능하다. 대부분이 읽기 요청이고 쓰기가 아주 작은 비율로 구성된 작업부하(웹 상의 공통 패턴)라면 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산하는 매력적인 옵션이 있다. 이 방식을 사용하려면 리더의 부하를 없애고 근처 복제 서버에서 읽기 요청을 처리할 수 있게 한다.

이런 읽기 확장(read-scaling) 아키텍처에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있다. 하지만 이 접근 방식은 실제로는 비동기식 복제에서만 동작을 한다. 동기식으로 모든 팔로워에 복제를 시도한다면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능해진다.  그리고 노드가 많아지면 다운될 가능성도 커져 완전한 동기시 설정은 매우 불안정하다.

애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있다. 이 상황은 데이터베이스에 명백하게 불일치가 발생한다. 이와 동시에 리더와 팔로워에 동일한 질의를 수행하면 모든 쓰기가 팔로워에 반영되지 않았기 때문에 서로 다른 결과를 얻을 수도 있다. 하지만 이런 불일치는 일시적 상태에 불과하다. 데이터베이스에 쓰기를 멈추고 잠시동안 기다리면 팔로워는 결국 따라잡게 되고 리더와 일치하게 된다. 이런 효과를 최종적 일관성이라 한다.

