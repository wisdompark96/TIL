## 목표
다양한 소프트웨어 개발 원칙을 배운다. 문서 관리 기능 설계의 핵심은 상속 관계, 즉 어떻게 클래스를 상속하거나 인터페이스를 구현하는가에 달렸다.
언제 상속을 사용해야 하는지와 관련해서는 '상속보다 조합'원칙도 알아야 한다.

## 문서 관리 시스템 요구 사항
문서 관리 시스템은 기존 환자 정보 파일을 읽어 색인을 추가하고 검색할 수 있는 형태의 정보로 변환해야 한다.
- 리포트 : 환자의 수술과 관련된 상담 내용을 기록한 본문이다.
- 우편물 : 특정 주소로 발송되는 텍스트 문서다.
- 이미지 : 치아와 잇몸 엑스레이 사진을 저장한다. 용량이 크다.

## 설계 작업
테스트 주도 개발(TDD)은 프로그램을 시작하는 아주 좋은 방법 중 하나이다. 문서 관리 시스템은 필요에 따라 문서를 임포트해 내부 문서 저장소에 추가한다. 두 메서드를 포함하는 DocumentManagementSystem 클래스를 만들어 이 요구 사항을 구현한다.
- void importFile(String path) 
사용자가 문서 관리 시스템으로 임포트하려는 파일의 경로를 받는다. 제품 시스템의 사용자의 입력을 받는 공개 API이므로 java.nio.Path나 java.io.File 같이 더 안전한 형식을 지원하는 클래스 대신 평범한 String을 사용한다.
- List<Document> contents()
문서 관리 시스템에 저장된 모든 문서의 목록을 반환한다.
contents()는 Document 클래스 목록을 반환한다는 점을 알 수 있다.

### 임포터
다양한 종류의 문서를 임포트하는 것이 문서 관리 시스템의 핵심 기능이다.
파일의 확장자로 파일을 어떻게 임포트할지 결정할 수 있다.

```
switch(extension) {
    case "letter":
        // 우편물 임포트 코드
        break;

    case "report:
        // 레포트 임포트 코드
        break;
    
    case "jpg":
        // 이미지 임포트 코드
        break;
    
    default:
        throw new UnKnownFileTypeException("For file: " + path);
}
```

위 코드로 문제를 해결할 수 있지만 확장성은 부족하다. 다른 종류의 파일을 추가할 때마다 switch문에 다른 항목을 추가해 구현해야 하기 때문이다. 

메인 클래스를 깔끔하고 단순하게 유지하기 위해 다양한 문서를 임포트하는 클래스로 분리하면, 각각의 임포트 동작을 따로 처리하므로 찾기 쉽고, 이해하기 쉬운 코드를 만들 수 있다. 다양한 종류의 문서 임포트를 지원하도록 먼저 Importer 인터페이스를 정의한다. Importer 인터페이스를 구현하는 각 클래스는 다양한 종류의 파일을 임포트한다.

String 대신 파일을 가리키는 전용 형식을 이용하므로 오류가 발생할 범위를 줄인다. 이 원칙을 적용하기 위해 Importer 인터페이스의 파라미터로 java.io.File 객체를 사용해 임포트하는 파일을 가리킨다.

```
interface Importer {
    Document importFile(File file) throws IOException;
}
```


### Document 클래스
각 문서는 검색할 수 있는 다양한 속성을 포함한다. 문서의 종류에 따라 포함하는 속성이 달라진다. 다양한 방법으로 Document를 정의할 수 있지만 각각 장단점이 있다.
응용프로그램에 직접 Map<String, String>을 사용하지 않는 이유가 뭘까? 한 문서를 모델링하려고 새 도메인 클래스를 소개하는 것은 식은 죽 먹기처럼 간단히 결정할 수 있는 일이 아니라 응용프로그램의 유지보수성과 가독성을 고려해야 하는 일이다.

훌륭한 소프트웨어 개발팀은 유비쿼터스 언어로 자신의 소프트웨어를 작성한다. 
동료나 고객과 대화할 때 소프트웨어의 다양한 기능을 어떤 공통 언어로 약속한다. 이때 사용한 어휘를 코드로 매핑하면 코드의 어떤 부분을 바꿔야 하는지 쉽게 알 수 있다. 이를 발견성이라 한다.

> 유비쿼터스 언어는 에릭 에번스가 집필한 도메인 주도 설계에서 처음 등장했다. 유비쿼터스 언어란 개발자와 사용자 모두가 사용할 수 있도록 설계, 공유된 공통 언어를 말한다.

강한 형식을 이용하면 데이터의 사용 방법을 규제할 수 있다. 예를 들어 Document 클래스는 불변 클래스, 즉 클래스를 생성한 다음에는 클래스의 속성을 바꿀 수 없다. Import 구현이 문서를 만들면 이후에 수정할 수 없다. 따라서 Documen의 속성에서 오류가 발생하면 해당 Document를 생성한 Importer구현을 확인하면 되므로 오류가 발생한 원인을 좁힐 수 있다. Document의 불변성 덕분에 안전하게 Document로 색인을 만들거나 Document정보를 캐시할 수 있다.

Document가 HashMap<String, String>을 상속받도록 설계를 결정한 개발자도 있을 것이다. 이런 설계 방법에는 몇 가지 문제가 있다.
소프트웨어를 설계할 때 필요한 기능은 추가하면서 동시에 불필요한 기능은 제한해야 한다.
Document 클래스가 HashMap을 상속하면서 응용프로그램이 Document 클래스를 바꿀 수 있도록 결정한다면 이전에 불변성으로 얻을 수 있는 모든 이득이 단번에 사라진다. 컬렉션으로 감싸면 get() 등의 메서드(아무 의미를 포함하지 않는 메서드명)로 속성을 검색하지 않고 의미를 갖는 메서드 이름을 사용할 수 있다.
요약하자면 도메인 클래스를 이용하면 개념에 이름을 붙이고 수행할 수 있는 동작과 값을 제한하므로 발견성을 개선하고 버그 발생 범위를 줄일 수 있다.

```
public class Document {
    private final Map<String, String> attributes;

    Document(final Map<String, String> attributes) {
        this.attributes = attributes;
    }

    public String getAttribute(final String attributeName) {
        return attributes.get(attributeName);
    }
}
```
보통 자바 클래스의 생성자는 public을 사용하지만 그러면 프로젝트의 어디에서나 그 형식의 객체를 만들 수 있는 문제가 생긴다. 오직 문서 관리 시스템에서만 Document를 만들 수 있어야 하므로 패키지 영역으로 생성자를 제공하고, 문서 관리 시스템이 위치한 패키지에만 접근 권한을 준다.
