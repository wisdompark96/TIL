## 관찰자(Observer) 패턴
관찰자 패턴은 관찰자라고 불리는 자손의 리스트를 가지고 있는 주체(subject)를 필요로 한다. 주체는 일반적으로 자신의 메서드 중 하나를 호출해 관찰자에게 상태 변경을 알린다. 이 패턴은 이벤트 처리를 기반으로 시스템을 구현할 때 필수적이다. 관찰자 패턴은 MVC(Model-View-Controller) 패턴의 중요한 부분이다. 거의 모든 UI 라이브러리가 내부적으로 이 패턴을 사용한다.

다중 스레드를 위한 관찰자 패턴이 필요할 때 현장에서 검증된 라이ㅡ러리를 사용하는 것이 좋다.
> 라이브니스에 관해 말할 때는 병행 컴퓨팅(또는 컨커런트 컴퓨팅, Concurrent computing)의 정의를 언급해야 한다. 병행 컴퓨팅은 여러 개의 계산을 연속적(하나씩 일을 마치는 것)으로 처리하지 않고 동시에 처리하는 것을 발한다.

Observer 및 Observable클래스는 자바 제네릭 이전에 도입됐기 때문에 Object타입을 사용하고, 이로 인해 타입 안전성이 보장되지 않는다. 또한 이러한 구현 방식은 멀티 스레드 환경에서 효율적이지 않다. 그러므로 응용프로그램을 개발할 때 이 클래스는 사용하지 말아야 한다.

## @EventLister를 사용한 발행-구독 패턴
발행-구독 패턴은 게시자와 구독자 간에 간접적인 계층을 제공한다. 구독자는 알림을 브로드캐스트하는 이벤트 채널을 알고 있지만, 일반적으로 게시자가 누구인지는 신경쓰지 않는다. 또한 각 이벤트 채널에는 동시에 몇 명의 게시자가 있을 수 있다.
이벤트 채널(메시지 브로커 또는 이벤트 버스라고도 함)은 수신 메시지를 구독자에게 배포하기 전에 필터링 작업을 할 수도 있다. 필터링 및 라우팅은 메시지 내용이나 메세지 주제, 때로는 둘 다에 의해 발생할 수 있다. 따라서 토픽 기반 시스템(topic-based system)의 구독자는 관심 토픽에 게시된 모든 메시지를 수신하게 된다.

스프맅 프레임워크의 @EventListener 애노테이션은 토픽 기반 라우팅과 내용 기반 라우팅 모두에 사용할 수 있다. 메시지 유형은 토픽 역할을 할 수 있다. 조건 속성은 스프링 표현 언어(Spring Expression Language, SpEL)를 사용하는 내용 기반 라우팅 이벤트 처리를 가능하게 한다.

## @EventListener 활용한 응용 프로그램 개발
리액티브 디자인에 따라 애플리케이션을 만들어야 하므로 고전적인 방식의 풀링 모델(pulling model)을 사용해 데이터를 조회할 수는 없다. 요즘에는 서버에서 클라이언트로의 비동기 메시지 전달을 할 수 있는 웹소켄(WebSocket) 및 SSE(Server-Sent Events)와 같은 잘 정의된 프로토콜이 있다.
SSE를 사용하면 클라이언트가 서버에서 자동으로 업데이트를 수신할 수 있다. 그렇기 때문에 일반적으로 일반적으로 SSE는 브라우저에 메시지를 업데이트하거나 연속적인 데이터 스트림을 보내는데 사용한다.
