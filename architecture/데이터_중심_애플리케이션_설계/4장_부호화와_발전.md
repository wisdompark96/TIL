애플리케이션 기능을 변경하려면 저장하는 데이터도 변경해야 한다.
관계형 데이터베이스는 일반적으로 데이터베이스의 모든 데이터가 하나의 스키마를 따른다고 가정한다. 비록 스키마는 변경될 수 있지만 특정 시점에는 정확하게 하나의 스키마가 적용된다.  
읽기 스키마("스키마리스(schemaless)") 데이터베이스는 스키마를 강요하지 않으므로 다른 시점에 쓰여진 이전 데이터 타입과 새로운 데이터 타입이 섞여 포함될 수 있다.
데이터 타입이나 스키마가 변경될 때 애플리케이션 코드에 대한 변경이 종종 발생한다(예를 들어 레코드에 새로운 필드가 추가되면 애플리케이션 코드는 해당 필드의 읽고 쓰기를 시작한다). 하지만 대규모 애플리케이션에서 코드 변경은 대개 즉시 반영할 수 없다.
- 서버 측 애플리케이션에서는 한 번에 몇 개의 노드에 새 버전을 배포하고 새로운 버전이 원활하게 실행되는지 확인한 다음 서서히 모든 노드에서 실행되게 하는 순회식 업그레이드(rolling upgrade)(단계적 롤아웃(staged rollout)이라고도 함)방식이 있다.
- 클라이언트 측 애플리케이션은 사용자에 전적으로 좌우된다. 어떤 사용자는 한동안 업데이트를 설치하지 않을 수도 있다.

시스템이 계속 원활하게 실행되게 하려면 양방향으로 호환성을 유지해야 한다.
**하위 호환성**  
새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
**상위 호환성**
예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.  


하위 호환성은 일반적으로 어렵지 않다. 새로운 코드 쓰기는 예전 버전의 코드가 기록한 데이터의 형식을 알기에 명시적으로 해당 형식을 다룰 수 있다(필요한 경우 예전 코드를 유지하고 이전 데이터를 읽을 수 있음). 상위 호환성은 에전 버전의 코드가 새 버전의 코드에 의해 추가된 것을 무시할 수 있어야 하므로 다루기 더 어렵다.

## 데이터 부호화 형식
프로그램은 보통(최소한) 두 가지 형태로 표현된 데이터를 사용해 동작한다.  
메모리에 객체(object), 구조체(struct), 목록(list), 배열(array), 해시 테이블(hash table), 트리(tree) 등올 데이터가 유지된다. 이런 데이터 구조는 CPU에서 효율적으로 접근하고 조작할 수 있게(보통은 포인터를 이용헤) 최적화된다.  
데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 바이트열(예를 들어 JSON 문서)의 형태로 부호화해야 한다.  
따라서 두 가지 표현 사이에 일종의 전환이 필요하다. 인메모리 표현에서 바이트열로의 전환을 부호화(직렬화나 마샬링이라고도 함)라고 하며, 그 반대를 복호화(파싱, 역직렬화, 언마샬링이라고도 함)라고 한다.

## 언어별 형식
많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 내장한다. 프로그래밍 언어에 내장된 부호화 라이브러리는 최소한의 추가 코드로 인메모리 객체를 저장하고 복원할 수 있기 때문에 매우 편리하지만 심각한 문제점 또한 많다.

- 부호화는 보통 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기는 매우 어렵다. 이런 부호화로 데이터를 저장하고 전송하는 경우 매우 오랜 시간이 될지도 모를 기간 동안 현재 프로그래밍 언어로만 코드를 작성해야할 뿐 아니라 다른 시스템(다른 언어를 사용할 수도 있음)과 통합하는 데 방해가 된다.

- 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다. 이것은 종종 보안 문제의 원인이 된다. 공격자가 임의의 바이트열로 복호화할 수 있는 애플리케이션을 얻을 수 있으면 임의의 클래스를 인스턴스화할 수 있고 공격자가 원격으로 임의 코드를 실행하는 것과 같은 끔찍한일이 발생할 수 있다.

- 효율성(부호화나 복호화에 소요되는 CPU 시간과 부호화된 구조체의 크기)도 종종 나중에 생각하게 된다.

이런 이유로 매우 일시적인 목적 외에 언어에 내장된 부호화를 사용하는 방식은 일반적으로 좋지 않다.

## JSON과 XML, 이진 변형
JSON, XML, CSV는 텍스트 형식이라서 어느 정도 사람이 읽을 수 있다. 피상적인 문법적 문제 외에도 일부 미묘한 문제가 있다.
- 수(number)의 부호화에는 많은 애매함이 있다. XML과 CSV에서는 수와 숫자(digit)로 구성된 문자열을 구분할 수 있다. JSON은 문자열과 수를 구분하지만 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다.
- 이 애매함은 큰 수를 다룰 때 문제가된다. 예를들어 2의 53승 보다 큰 정수는 IEEE 754 배정도로 부동소수점 수에서는 정확하게 표현할 수 없으므로 이런 수는 부동소수점 수를 사용하는 (자바스크립트 같은) 언어에서는 파싱할 때 부정확해질 수 있다. 트위터의 API에서 반환된 JSON 은 JSON 수로 한번, 10진 문자열로 한번, 이렇게 트윗 ID가 두 번 포함되는데 자바스크림트 애플리케이션에서 정확하게 숫자를 파싱하지 않는 문제를 해결한다.
- JSON과 XML은 유니코드 문자열(즉, 사람이 읽을 수 있는 텍스트)을 잘 지원한다. 그러나 이진 문자열(문자 부호화가 없는 바이트열)을 지원하지 않는다. 이진 문자열은 매우 유용한 기능이기 때문에 사람들은 이진 데이터를 Base64를 사용해 텍스트로 부호화해 이런 제한을 피한다. 그런 다음 값이 Base64로 부호화됐기 때문에 해석해야 한다는 사실을 스키마를 사용해 표시한다.
- XML과 JSON 모두 스키마를 지원한다. XML과 JSON을 정의하는 스키마 언어는 상당히 강력하지만 익히고 구현하기가 상당히 난해하다. 
- CSV는 스키마가 없으므로 각 로우와 칼럼의 의미를 정의하는 작업은 애플리케이션이 해야 한다. 애플리케이션이 새로운 로우나 칼럼 추가를 변경하려면 수동으로 변경을 처리해야한다. 또한 CSV는 매우 모호한 형식이다. 이스케이핑 규칙을 공식적으로 규정했지만 모든 파서가 규칙을 정확하게 구현하지는 않는다.

## 이진 부호화
조직 내에서만 사용하는 데이터라면 최소공통분모 부호화 형식을 사용해야 하는 부담감이 덜하다. 예를 들면 조금 더 간편하고 파싱이 빠른 형식을 선택할 수 있다. 작은 데이터셋의 경우에는 부호화 형식 선택으로 얻는 이득이 무시할 정도지만 테라바이트 정도가 되면 데이터 타입의 선택이 큰 영향을 미친다.

### 스리프트와 프로토콜 버퍼
스피프트와 프로토콜 버퍼는 각각 스키마 정의를 사용해 코드를 생성하는 도구가 있다. 이 도구는 다양한 프로그래밍 언어로 스키마를 구현한 클래스를 생성한다. 애플리케이션 코드는 생성된 코드를 호춯해 스키마의 레코드를 부호화하고 복호화할 수 있다.


### 아브로
아파치 아브로는 이진 부호화 형식이다. 아브로도 부호화할 데이터 구조를 지정하기 위해 스키마를 사용한다. 아브로에는 두 개의 스키마 언어가 잇다. 하나는 사람이 편집할 수 있는 아브로 IDL(Avro IDL)이고 하나는 기계가 더 쉽게 읽을 수 있는 JSON기반 언어다.
아브로를 이용해 이진 데이터를 파싱하려면 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터타입을 미리 파악해야한다. 이것은 데이터를 읽는 코드가 데이터를 기록한 코드와 정확히 같은 스키마를 사용하는 경우에만 이진 데이터를 올바르게 복호화할 수 있음을 의미한다. 즉 읽기와 쓰기 간 스키마가 불일치한다면 데이터 복호화가 정확하지 않다는 의미다.

### 쓰기 스키마와 읽기 스키마
애플리케이션이 파일이나 데이터베이스에 쓰기 위해 또는 네트워크를 통해 전송 등의 목적으로 어떤 데이터를 아브로로 부호화하길 원한다면 알고 있는 스키마 버전을 사용해 데이터를 부호화한다. 예를 들어 해당 스키마를 애플리케이션에 포함할 수 있고 이를 쓰기 스키마라고 한다.
애플리케이션이 파일이나 데이터베이스에서 또는 네트워크로부터 수신 등으로 읽은 어떤 데이터를 복호화하길 원한다면 데이터가 특정 스키마로 복호화하길 기대한다. 이 스키마를 읽기 스키마라 한다. 애플리케이션 코드는 이 스키마에 의존한다. 복호화 코드는 애플리케이션을 빌드하는 동안 스키마로부터 생성된다.

아브로의 핵심 아이디어는 쓰기 스키마와 읽기 스키마가 동일하지 않아도 되며 단지 호환 가능하면 된다는 것이다. 데이터를 복호화(읽기)할 때 아브로 라이브러리는 쓰기 스키마와 읽기 스키마를 함께 살펴본 다음 쓰기 스키마에서 읽기 스키마로 데이터를 변환해 그 차이를 해소한다.

### 스키마 발전 규칙
아브로에서 상위 호환성은 새로운 버전의 쓰기 스키마와 예전 버전의 읽기 스키마를 가질 수 있음을 의미한다. 반대로 하위 호환성은 새로운 버전의 읽기 스키마와 예전 버전의 쓰기 스키마를 가질 수 있음을 의미한다. 
호환성을 유지하기 위해서는 기본값이 있는 필드만 추가하거나 삭제할 수 있다. 새로운 스키마를 사용하는 읽기가 예전 스키마로 기록된 레코드를 읽으면 누락된 필드는 기본값로 채워진다.

기본값이 없는 필드를 추가하면 새로운 읽기는 예전 쓰기가 기록한 데이터를 읽을 수 없기때문에 하위 호환성이 깨진다. 기본값이 없는 필드를 삭제하면 예전 읽기는 새로운 쓰기가 기록한 데이터를 읽을 수 없기 때문에 상위 호환성이 깨진다.
일부 프로그래밍언어에서 널은 임의 변수의 기본값으로 허용하지만 이브로는 그렇지 않다. 필드에 널을 허용하려면 유니온 타입(union type)을 사용해야 한다.

결과적으로 아브로는 프로토콜 버퍼, 스리프트와 동일한 방식의 optional과 required 표시자를 가지고 있지 않다.

### 그러면 쓰기 스키마는 무엇인가?
읽기는 특정 데이터를 부호화한 쓰기 스키마를 어떻게 알 수 있을까? 모든 레코드에 전체 스키마를 포함시킬 수는 없다. 왜냐하면 스키마는 부호화된 데이터보다 훨씬 클 가능성이 있기 때문이다.

**많은 레코드가 있는 대용량 파일**  
아브로의 일반적인 용도는 모두 동일한 스키마로 부호화된 수백만 개 레코드를 포함한 큰 파일을 저장하는 용도다. 이 경우 파일의 쓰기는 파일의 시작 부분에 한 번만 쓰기 스키마를 포함시키면 된다. 아브로는 이를 위해 파일 형식을 명시한다.
**개별적으로 기록된 레코드를 가진 데이터베이스**
데이터베이스의 다양한 레코드들은 다양한 쓰기 스키마를 사용해 서로 다른 시점에 쓰여질 수 있다. 즉 모든 레코드가 동일한 스키마를 가진다고 가정할 수 없다. 가장 간단한 해결책으로 모든 부호화된 레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스에는 스키마 버전 목록을 유지한다. 

**네트워크 연결을 통해 레코드 보내기**  
두 프로세스가 양방향 네트워크 연결을 통해 통신할 때 연결 설정에서 스키마 버전 합의를 할 수 있다. 이후 연결을 유지하는 동안 합의된 스키마를 사용한다. 아브로 RPC프로토콜이 이처럼 동작한다.

스키마 버전을 사용하는 데이터베이스는 어떤 경우라도 유용하다. 스키마 버전들이 설명서처럼 동작해 스키마 호환성체크를 직접할 수 있기 때문이다.
