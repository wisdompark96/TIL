## API 불일치 문제
많은 라이브러리와 프레임워크는 구성 요소 간의 비동기 통신을 위한 자체 인터페이스와 클래스를 제공한다. 대부분의 경우, 문제를 해결하고 여러 독립 라이브러리를 호환할 수 있게 하기 위해서는 개발자들이 라이브러리 일부를 수정해 재사용해야 한다.
## 풀 방식과 푸시 방식
```
public Observable<Item> list(int count) {
    return dbClient.getStreamOfItems()
                .filter(item -> isValid(item))
                .take(count);
}
```
AsyncDatabaseClient#getStreamOfItems 메서드를 호출해 데이터베이스를 구독한다.
항목을 필터링하고 연산자 take()를 사용해 호출자가 요청한 개수만큼의 데이터를 얻는다.
여기서는 푸시된 원소를 수신하는 1급 객체로 RxJava 1.x클래스를 사용한다. 다음으로, 모든 요구사항이 충족되면 취소 신호가 보내지고 데이터베이스 연결이 닫힌다.

이방법에서 데이터베이스는 필요한수의 원소를 처리한 이후에도 서비스에서 사용하지 않을 항목을 여전히 생성할 수도 있다.

## 흐름 제어
메시지 기반 통신의 본질은 요청에 응답하는 것이다. 이는 비동기적이며 잠재적으로 무한한 메시지 스트림을 서비스가 수신할 수 있다고 가정해야 한다. 프로듀서가 컨슈머의 처리 능력을 무시하면 전반적인 시스템 안전성에 영향을 미칠 수 있기 때문에 이는 까다로운 부분이다.

### 느린 프로듀서와 빠른 컨슈머
이러한 상호아은 알려지지 않은 컨슈머의 능력에 대해 프로듀서가 믿지 못하기 때문에 발생할 수 있다.
순수 푸시 모델은 동적으로 시스템의 처리량을 증가 시키는 것은 불가능하다.

### 빠른 프로듀서와 느린 컨슈머
프로듀서가 컨슈머가 처리할 수 있는 것보다 훨씬 많은 데이터를 전송할수 있으며 이로 인해 부하를 받는 컴포넌트에 치명적인 오류가 발생할 수 있다.
이러한 경우에 대한 직관적인 솔루션은 처리되지 않은 원소를 큐에 수집하는 것으로, 큐는 프로듀서와 컨슈머 사이에 있을 수도 있고 컨슈머측에 있을 수도 있다. 
컨슈머가 바쁘다고 해도 이러한 기술을 사용하면 이전 원소나 데이터의 일부를 처리해 새 데이터를 처리할 수 있다.
큐를 사용해 푸시된 데이터를 처리할 때 중요한 것 중 하나는 적절한 특성을 가진 큐를 선택하는 것이다. 일반적으로 세 가지 유형의 큐가 있다.

### 무제한 큐
가장 확실한 첫 번째 해결책은 큐의 사이즈를 제한하지 않고 사용하는 것이다. 이 경우 생성된 모든 원소가 먼저 큐에 저장되고 나서 구독자에 의해 사용된다.
무제한 큐를 사용해 메시지를 처리해서 얻을 수 있는 주요 이점은 메시지 전달에 대해 확신할 수 있다는 것이다. 즉, 모든 메세지는 반드시 컨슈머에 전달될 것이고 컨슈머는 이를 처리하려고 할 것이다. 반면에 실제 리소스가 무제한일 수는 없으므로 메시지 전달을 계속 수행하면 응용 프로그램의 복원력이 떨어진다.

### 크기가 제한된 드롭 큐
메모리 오버플로를 방지하기 위해 큐가 가득 차면 신규 유입된 메시지를 무시하는 형태의 큐를 사용할 수 있다.
이 기술을 이용하면 자원의 한계를 고려해 허용 용량에 따라 큐의 용량을 구성할 수 있다. 이러한 큐의 메시지의 중요성이 낮을 때 일반적으로 사용된다. 

### 크기가 제한된 블로킹 큐
앞의 기술은 각 메시지가 중요한 경우에는 사용하지 못할 수 있다. 결과적으로 메시지를 삭제하고 푸시된 데이터를 처리하는 방법으로 큐를 유지하는 대신 제한에 도달하면 메시지 유입을 차단할 수 있다. 유입을 차단하는 기능을 특징으로 하는 큐를 일반적으로 블로킹 큐라고 한다
이 기술은 시스템의 비동기 동작을 모두 무효화한다. 일반적으로 큐의 한계에 도달하면 차단이 시작되고 컨슈머가 요소를 고갈시키고 큐의 여유공간을 사용할 수 있을 때까지 차단 상태가 된다. 
가장 느린 컨슈머의 처리량에 의해 시스템의 전체 처리량이 제한된다고 볼 수 있다. 비동기 동작을 무효화하는 것과 함께 이 기술은 효율적으로 리소스를 사용하지 못한다. 결과적으로 복원력, 탄력성, 응답성 세가지를 모두 달성하고자 한다면 절대 받아들일 수 없는 시나리오 이다.
또한 큐가 있으면 시스템의 전체적인 설계가 복잡해질 수 있으며 결합된 솔루션 간의 균형을 찾는 추가적인 고려사항이 발생한다.
일반적으로 적합한 제어를 추가하지 않은 순수한 푸시 모델은 다양한 부작용을 발생시킬 수 있다. 이것이 리액티브 선언문이 시스템 부하에 적절하게 대응하는 방법, 즉 배압 제어 메커니즘의 중요성을 언급한 이유이다.

## 리액티브 스트림의 기본
리액티브 스트림 스첵에는 Publisher, Subscriber, Subscription, Processor의 네 가지 기본 인터페이스가 정의돼 있다.

```
public interface Subscription {
    void request(long n);
    void cancel();
}
```
Subscription은 원소 생성을 제어하기 위해 기본적인 사항을 제공한다. cacel() 메서드가 있어서 스트림에서 구독을 취소하거나 발행을 완전히 취소할 수 있다. 
리액티브 스트림에서는 Publisher와 Subscriber 사이의 상호작용을 확장하기 위해  request 메서드를 도입했다.
Subscriber는 request메서드를 통해 요청하는 Publisher가 보내줘야 하는 데이터 크기를 알러줄 수 있으며, 이를 통해 Publisher에서 유입되는 원소의 개수가 처리할 수 있는 제한을 초과하지 않을 것 임을 확신할 수 있다.
또한 순수 푸시 모델과는 달리 스펙에는 배압을 적절하게 제어할 수 있는 하이브리드 푸시-풀 모델이 포함돼 있다.

## Processor 개념의 소개
정의에 따라 시작 지점과 끝 지점을 의미하는 Publisher 및 Subscriber와 달리 Processer는 Publisher와 Subscriber 사이에 몇 가지 처리 단계를 추가하도록 설계됐다. Processor는 일부 변환 로직을 Processor의 사용 예로는 커스텀 연산자로 구현할 수 있는 비즈니스 로직이나 스트리밍 데이터의 추가 캐싱을 제공하는 것 등이 있다.
Processor를 구성하면 별도의 Subscriber 관리 및 적절한 배압 구현을 위한 추가적인 노력이 필요하다. 그 결과, Processor성능이 저하되거나 전체 스트림 처리량이 저하될 수 있다.
Processor는 구독자의 존재 여부와 상관없이 멀티 캐스팅해야 할 때 그 진가를 알 수 있다. 또한 캐싱과 같은 변형을 효과적으로 구현할 수 있는 Subscriber 인터페이스를 구현하기 때문에 다양한 변형을 할 수 있다.