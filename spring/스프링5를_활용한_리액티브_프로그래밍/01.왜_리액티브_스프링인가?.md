## 왜 리액티브인가?
일차적인 목표를 달성하는 첫 번째 방법은 탄력성(elasticity)을 통한 것이다.
이는 다양한 작업 부하에서 응답성을 유지하는 능력을 의미한다. 즉, 더 많은 사용자가 작업을 시작할 때 시스템 처리량이 자동으로 증가해야 하고 수요가 감소하면 자동으로 감소해야한다. 애플리케이션 관점에서 볼 때 이 가능을 사용하면 평균 지연 시간에 영향을 미치지 않고 시스템을 확장할 수 있기 때문에 시스템 응답성을 유지할 수 있다.

> 지연 시간은(latency)은 응답성의 필수적인 특성이다. 탄력성이 없는 시스템에서는 수요가 증가하면 평균 지연 시간이 증가하고, 이것이 시스템의 응답성에 직접적인 영향을 미친다.

탄력성과 복원력이 밀접하게 결합돼 있으며, 이 두가지를 모두 사용할 때만 시스템의 진정한 응답성을 달성할 수 있다. 확장성을 통해 다수의 복제본을 가질 수 있으므로 하나의 노드에 장애가 발생한 경우 이를 탐지하고 시스템의 나머지 부분에 미치는 영향을 최소화하며 다른 본제본으로 전환할 수 있다.

## 메시지 기반 통신
자바에는 병렬 처리를 위해 추가 스레드를 할당할 수 있는 스레드 풀이 있다. 그러나 부하가 높은 상태에서는 이러한 기법이 새로운 I/O 작업을 동시에 처리하는데 매우 비효율적일 수 있다. 
일반적으로 분산 시스템에서 서비스 간에 통신할 때 자원을 효율적으로 사용하기 위해서는 메시지 기반(message-driven)통신 원칙을 따라야 한다. 서비스 사이에 일어나는 전반적인 상호 작용은 다음과 같이 설명할 수 있다. 구성 요소들은 메시지 도착을 기다리고 이에 반응하며, 나머지 시간에는 휴면 상태에 있지만, 동시에 논블로킹 방식으로 메시지를 보낼 수 있어야 한다. 또한 이러한 접근 방식은 위치 투명성을 활성화 해 시스템 확장성을 향상시킨다. 
메시지 기반 통신을 수행하는 방법의 하나는 메시지 브로커(message brokder)를 사용하는 것이다. 이 경우 메시지 대기열을 모니터링해 시스템이 부하 관리 및 탄력성을 제어할 수 있다. 또한 메시지 통신은 명확한 흐름 제어를 제공하고 전체 설계를 단순화한다.
분산 시스템으로 구현되는 모든 비즈니스의 핵심 가치는 응답성이다. 시스템이 높은 응답성을 확보한ㄷ는 것은 탄력성 및 복원력 같은 기본 기법을 따른다는 의미이다. 마지막으로 응답성, 탄력성 및 복원력을 모두 확보하는 기본적인 방법의 하나는 메시지 기반 통신을 사용하는 것이다. 
이러한 원칙에 따라 구축된 시스템은 모든 구성 요소가 독립적이고 적절하게 격리돼 있기 때문에 유지 보수 및 확장이 매우 용이하다.

## 서비스 레벨에서의 반응성
리액티브 시스템의 관점에서 블로킹 통신은 허용하지 않는다.
자바에서는 이 문제를 컴포넌트 사이의 통신을 위한 콜백 기법을 적용해 해결할 수 있다.
이러한 방식의 장점은 컴포넌트가 콜백 함수에 의해 분리된다는 것이다. 단점이라면 공유데이터 변경 및 콜백 지옥을 피하기 위해 개발자가 멀티 스레딩을 잘 이해하고 있어야한다.
또 하나의 대안은 java.util.concurrent.Future이다. 이 클래스는 실행동작을 어느정도 숨기고 구성 요소도 분리한다.
멀티 스레딩은 본질적으로 복잡한 기술이다. 멀티 스레딩을 할 때는 여러 스레드에서 공유 메모리에 액세스, 동기화, 오류 처리 등과 같은 많은 작업을 생각해야 한다. 자바에 있는 멀티 스레딩 디자인은 몇몇 스레드가 그들의 작업을 동시에 실행하기 위해 하나의 CPU를 공유할 수도 있다고 가정했다. CPU 시간이 여러 스레드 간에 공유된다는 사실은 컨텍스트 스위칭(context switching)이라는 개념을 끌어들인다. 즉, 나중에 스레드를 다시 시작하려면 레지스터, 메모리 맵 및 기타 관련 요소를 저장하고 불러와야 한다. 결과적으로 적은 수의 CPU애 동시에 많은 수의 스레드를 활성화 시키는 응용 프로그램은 비효율적이다.

일반적인 자바 스레드는 메모리 소비에 오버헤드가 있다.(모던 자바 인 액션 #스레드와 높은 수준의 추상화) 64비트 JVM에서 스레드의 일반적인 스택 크기는 1,024kb이다. 한편, 커넥션 마다 별도의 스레드를 할당하는 모델에서 64,000개의 동시 요청을 처리하려는 시도는 약 64GB의 메모리를 필요로 한다. 이는 비즈니스 관점에서 볼 때 비용이 많이 들고 애플리케이션 관점에서 위험한 일일 수 있다. 제한된 크기 스레드 풀을 제공하는 기존 모델로 전환하고 요청에 대해 미리 구성된 대기열을 사용하면 클라이언트가 응답을 받기까지의 대기 시간이 길어지고 평균 응답 시간이 길어지면서 결국 응용프로그램이 응답하지 않을 수 있다.
이를 위해 리액티브 선언문은 논블로킹 작업을 사용하도록 권장했으나, 스프링 생태계에서는 누락돼 있다.

