## 리액터 프로젝트의 간략한 역사
리액티브 스트림 스펙으니 리액티브 라이브러리가 서로 호환할 수 있게 해주며, 풀-푸시 데이터 교환모델을 도입해 배압 문제를 해결했다. 
### 리액터 프로젝트 버전 1.x
> 리액터 패턴은 비동기 이벤트 처리 및 동기 처리에 도움이 되는 행위 패턴이다. 즉, 모든 이벤트가 큐에 추가되고 이벤트는 나중에 별도의 스레드 에 의해 처리된다.

```
Environment env = new Environment(); //1
Reactor reactor = Reactors.reactor() //2
                        .env(env)
                        .dispatcher(Environment.RING_BUFFER)//2.1
                        .get();
reactor.on($("channel"),
            envent -> System.out.printl(envent.getData())); //3
Exectuors.newSingleThreadScheduledExecutor() //4
        .scheduleAtFixedRate(
            () -> reactor.notify("channel", Event.wrap("test")),
            0, 100, TimeUnit.MILLISECONDS
        );
```
1. Environment 인스턴스를 만든다. Environment 인스턴스는 특정 Dispatcher를 만들기 위한 실행 컨텍스트이다.
2. Reactor 패턴을 직접 구현한 Reactor  클래스의 인스턴스를 생성한다.
3. 채널 Selector 및 이벤트 컨슈머를 선언하고 이벤트 핸들러를 등록한다.(예제의 경우에는 수신한 모든 이벤트를 System.out에 프린트하는 람다 표현식).
4. 예약된 작업의 형태로 이벤트 프로듀서를 구성한다. 

리액터 1.x 라이브러리에는 배압 조절기능이 없다. 리액터 1.x의 이벤트 기반 구현은 프로듀서 스레드를 차단하거나 이벤트를 생략하는 것 이외에 다른 배압 제어 방법을 제공하지 못했다.

### 리액터 프로젝트 버전 2.x
리액터 디자인의 가장 중요한 변화는 이벤트버스 및 스트림 기능을 별도의 모듈로 추출한 것이다. 또한 새로운 리액터 스트림(Reactor Streams) 라이브러리가 리액티브 스트림 스펙을 완벽하게 준수하도록 핵심 모듈까지 다시 설계하였다.

## 리액터 프로젝트 필수 요소
처음부터 리액터 라이브러리는 비동기 파이프라인을 구축할 때 콜백 지옥과 깊게 중첩된 코드를 생략하는 목적으로 설계됐다.
라이브러리의 기본 목표는 코드 가독성을 높이고 리액터 라이브러리에 의해 정의된 워크플로에 조합성(composability)을 추가하는 것이다.
리액터 API는 연산자를 연결해서 사용하는 것을 권장한다. 이를 통해 복잡하고 잠재적으로 재사용 가능한 실행 그래프를 작성할 수 있다. 이러한 실행 그래프는 실행 흐름만 정의하지만, 구독자가 실제로 구독을 만들 때까지 아무일도 발생하지 않으므로 실제 구독을 했을 때만 데이터 플로가 기동된다.
이 라이브러리는 내부 데이터, 외부 데이터와 관계없이 오류가 발생할 가능성이 있는 비동기 요청의 결과를 효율적으로 처리할 수 있도록 설계됐다.리액터 프로젝트의 오류 처리 연산자는 매우 유연하지만, 복원력 있는 코드를 작성할 수 있게 해준다.
리액티브 스트림 스펙을 구현하기 위해 배압은 꼭 필요한 핵심 속성이다. 리액터 역시 이 스펙을 구현했기 때문에 배압이 핵심 요소이다. 따라서 리액터로 제작된 리액티브 스트림을 이용해 데이터가 게시자로부터 구독자 쪽으로 이동하는 것을 이야기하는 것은 그와 동시에 구독 및 수요 제어 신호가 구독자에서 게시자에게 전달되는 것을 이야기한다.

라이브러리는 다음과 같이 배압 전파의 일반적인 모드를 지원한다.
- 푸시 전용: 구독자가 효과적으로 무한한 숫자를 요청하는 경우
    subscription.request(Long.MAX_VALUE)
- 풀 전용: 구독자가 이전 요소를 받은 후에만 다음 요소를 요청하는 경우
    subscriiption.request(1)
- 풀-푸시(혼합형이라고 불림): 구독자가 수요를 실시간 제어할 수 있고 게시자가 데이터 소비 속도에 적응할 수 있는 경우

리액터 프로젝트는 동시성에 좌우되지 않도록 설계됐으므로 동시성 모델을 적용하지 않는다. 동시에 거의 모든 방식으로 실행 스레드를 관리할 수 있는 유용한 스케줄러 세트를 제공한다. 또한 제공된 스케줄러 중 어느 것도 요구 사항에 적합하지 않다면 개발자가 로우 레벨 제어 기능을 갖춘 자체 스케줄러를 만들 수도 있다.

## 프로젝트에 리액터 추가하기
### 리액티브 타입 - Flux와 Mono
**Flux**
 Flux는 0, 1, 또는 여러 요소를 생성할 수 있는 일반적인 리액티브 스트림을 정의한다. 잠재적으로 무한한 양의 요소를 만들 수도 있다.
 ```
 onNext x 0..N [onError | onComplete]
 ```
구독자는 언제든지 구독을 취소할 수 있고 효과적으로 무한 스트림을 유한 스트림으로 변환할 수 있다.
> 주의: 무한 스트림에 의해 만들어진 모든 요소를 수집하려는 시도는 OutOfMemoryError를 유발할 수 있다. 운영 환경에서는 추천하지 않는 방법이다.

```
Flux.range(1, 100) //1
    .repeat() //2
    .collectList() //3
    .block(); //4
```
1. range 연산자는 1부터 100까지의 정수 시퀀스를 만든다.
2. repeat 연산자는 소스 스트림이 끝난 후 소스 스트림을 다시 구독한다.
3. collectList 연산자를 사용해 생성된 모든 요소를 단일 리스트로 만든다. 반복 연산자가 끝없는 스트림을 생성하기 때문에 요소가 도착하고 목록의 크기가 늘어나면 모든 메모리가 소모돼 응용 프로그램이 java.lang.OutOfMemoryError를 발생시킬 것이다.
4. block연산자는 실제 구독을 가동하고 최종결과가 도착할 때까지 실행중인 스레드를 차단한다.

**Mono**
Flux와 달리 Mono는 최대 하나의 요소를 생성할 수 있는 스트림을 정의하며 다음 표현식으로 나타낼 수 있다.
```
onNext x 0..1 [onError | onComplete]
```
버퍼 중복과 값비싼 동기화 작업을 생략하기 때문에 Mono를 보다 효율적으로 사용할 수 있게 해준다.
Mono<T>는 응용 프로그램 API가 최대 하나의 원소를 반환하는 경우 유용할 것이다. 결과적으로 봤을 때 CompletableFuture<T>와 의미론적으로 동일하기 때문에 비슷한 용도로 사용할 수 있다. 
이 두 유형에는 약간의 의미론적 차이가 있다. CompletableFuture는 Mono와 달리 반드시 반환값을 반환해야 한다. 또한 CompletableFuture는 즉시 처리를 시작하고 Mono는 구독자가 나타날 때까지 아무작업도 수행하지 않는다. Mono 타입의 이점은 리액티브 연산자를 많이 제공하고, 더 큰 규모의 리액티브 워크플로와 완벽하게 통합할 수 있다는 점이다.

또한 Mono는 클라이언트에게 작업이 완료됐음을 알리는 데 사용할 수 있다. 그 경우 Mono<Void> 유형을 반환하고 처리가 완료되면 onComplete() 신호를 보내거나 실패한 경우 onError() 신호를 보냅니다. 이러한 시나리오에서 데이터를 반환하지는 않지만, 이후 연산을 위한 알림을 보내는 용도로 사용할 수 있다.

Mono와 Flux는 서로 완전히 분리된 것이 아니라 서로 쉽게 변환할 수 있다. 예를 들어 Flux<T>.collectList()는 Mono<List<T>>를 반환하고, Mono<T>.flux()는 Flux<T>를 반환한다. 또한 라이브러리는 의미를 훼손하지 않고 변환을 최적화한다.

## RxJava 2의 리액티브 타입
### 리액티브 타입 - Observable
RxJava 2의 Observable 타입은 RxJava 1.x와 거의 동일한 의미를 제공하지만, null값을 허용하지 않는다. 또한 Observable은 배압을 지원하지 않으며 Publisher 인터페이스를 구현하지 않는다. 그래서 리액티브 스트림 스펙과 직접 호환되지는 않는다.
Observable 타입은 Flowable 타입보다 오버헤드가 적다. 사용자가 선택한 배압 전략을 적용해 스트림을 Flowable로 변환하는 toFlowable 메서드가 있다.

### 리액티브 타입 - Flowable
Flowable 타입은 리액터의 Flux 타입과 동일한 역할로써 리액티브 스트림의 Publisher를 구현했다.
Flux가 라이브러리에 좀 더 의존적인 반면, Flowable API는 publisher 유형의 인수를 사용할 수 있도록 잘 설계돼 있기 때문에 리액터 프로젝트로 구현된 리액티브 워크플로에서 쉽게 사용할 수 있다.

### 리액티브 타입 - Single
정확히 하나의 요소를 생성하는 스트림을 나타낸다. Publisher 인터페이스를 상속하지 않는다. Single 타입도 toFlowable 메서드를 가지고 있으나, 배압 전략이 필요하지 않는다. Single은 리액터의 Mono 타입보다 CompletableFuture의 의미를 더 잘 표현한다. 그러나 구독이 발생했을 때만 처리를 시작한다.

### 리액티브 타입 - Maybe
리액터의 Mono 타입과 동일한 의도를 구현하기 위해 RxJava 2.x는 Maybe 타입을 제공한다. 그러나 Publisher 인터페이스를 구현하지 않기 때문에 리액티브 스트림과 호환성이 없다. 그런 목적으로 toFlowable 메서드를 제공한다.

### Completable
RxJava 2.x에는 onError 또는 onComplete 신호만 발생시키고 onNext 신호는 생성할 수 없는 Completable 유형이 있다. 그것은 Publisher 인터페이스를 구현하지 않으며 toFlowable 메서드를 가진다. 의미상으로는 onNext 신호를 생성할 수 없는 Mono<Void> 타입에 해당한다.

## Flux와 Mono 시퀀스 만들기
Flux 및 Mono는 데이터를 기반으로 리액티브 스트림을 생성하는 많은 팩토리 메서드를 제공한다.
```
Flux<String> stream1 = Flux.just("Hello", "world");
Flux<Integer> stream2 = Flux.fromArray(new Integer[]{1, 2, 3});
Flux<Integer> stream3 = Flux.fromIterable(Arrays.asList(9, 8, 7));
```

Mono는 비슷한 팩토리 메서드를 제공하지만, 주로 하나의 요소를 대상으로 한다. nullable 및 Optional 타입과 함께 사용한다.
```
Mono<String> stream5 = Mono.just("One");
Mono<String> stream6 = Mono.justOrEmpty(null);
Mono<String> stream7 = Mono.justOrEmpty(Optional.empty());
```
Mono는 Http 요청이나 DB 쿼리와 같은 비동기 작업을 래핑하는 데 매우 유용하다. 이를 위해 Mono는 fromCallable(Callable), fromRunnable(Runnable), fromSupplier(Supplier), fromFuture(CompletableFuture), fromCompleteStionStage(CompletionStage) 등의 메서드를 제공한다.
```
Mono<String> stream8 = Mono.fromCallable(() -> httpRequest());
```

## 리액티브 스트림 구독하기

```
subscribe();// 1
subscribe(Consumer<T> dataConsumer);// 2
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer); // 3
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer, Runable completeConsumer); // 4
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer, Runable completeConsumer, Consumer<Subscription> subscriptionConsumer); // 5
subscribe(Subscriber<T> subscriber); // 6
```
1 ~ 4의 경우, 구독은 무제한(Long.MAX_VALUE) 요청한다.
1. 스트림을 구독하는 가장 간단한 방법. 이 메서드는 모든 신호를 무시한다.
2. dataConsumer는 값(onNext)마다 호출된다. onError및 onComplete는 처리하지 않는다.
3. 2에서와 동일하지만, 이 경우에는 onError를 처리할 수 있다.
4. 3과 동일하지만, onComplete를 처리할 수 있다.
5. 오류 처리 및 완료를 포함해 리액티브 스트림의 모든 요소를 처리한다. 이 오버라이드는 적절한 양의 데이터를 요구함으로써 구독을 제어할 수 있게 하지만, 무한 스트림을 요청할 수 있다. 
6. 시퀀스를 구독하는 가장 일반적인 바업 구독자 구현에 원하는 동작을 추가할 수 있다. 이 옵션은 매우 다양한 기능을 추가할 수 있지만, 거의 필요없다.

리액티브 스트림은 프로듀서가(onError 또는 onComplete 신호를 사용해) 종료하거나 Subscription 인스턴스를 통해 구독자가 취소할 수 있음을 기억하는 것도 중요하다. 또한, Disposable 인스턴스는 취소 목적으로 사용할 수도 있다. 보통은 구독자에 사용하는 것보다는 상위 레벨의 추상화 코드에서 사용한다.
```
Disposable disposable = Flux.interval(Duration.ofMillis(50)) // 1
    .subscribe( // 2
        data -> log.info("onNext: {}", data)
    );
Thread.sleep(200); // 3
disposable.dispose(); // 4
```
1. interval 팩토리 메서드는 주기적(50밀리초)으로 이벤트를 생성할 수 있다. 스트림은 무한히 생성된다.
2. onNext 시그널에 대한 핸들러만 제공해 구독한다.
3. 두 개의 이벤트를 받을 때까지 잠시 대기한다.
4. 내부적으로 구독을 취소하는 dispose 메서드를 호출한다.

### 사용자 정의 Subscriber 구현하기
기본 subscribe(...) 메서드만으로 필요한 요구 사항을 만족하지 못한다면 직접 Subscriber를 구현할 수 있다. 리액티브 스트림 스펙에 따라 Subscriber 인터페이스를 직접 구현하고 스트림을 구독할 수 있다.
> 예제 141p
다음 예제에서 구독을 정의하는 접근 방식은 올바르지 않는다. 1차원적 코드 흐름이 깨지며 오류가 발생하기 쉽다. 가장 어려운 부분은 스스로 배압을 관리하고 가입자에 대한 모든 TCK요구 사항을 올바르게 구현해야 한다는 점이다. 
대신 리액터 프로젝트에서 제공하는 BaseSubscriber 클래스를 상속하는 것이 훨씬 더 좋은 방법이다. 

BaseSubscriber 클래스는 request(long) 및 requestUnbounded() 메서드를 사용해 리액티브 스트림 수요를 세밀하게 제어할 수 있는 메서드를 제공한다. 또한 BaseSubscriber 클래스를 사용하면 TCK에 호환되는 구독자를 훨씬 쉽게 구현할 수 있다. 이러한 접근은 구독자 자체가 세심한 라이프 사이클 관리가 필요한 리소스를 포함하는 경우에 바람직할 수 있다.

### 연산자를 이용해 리액티브 시퀀스 변환하기
리액티브 시퀀스를 이용해 작업할 때는 스트림을 생성하고 소비하는 것 외에도 스트림을 완벽하게 변환하고 조작할 수 있어야 한다.
리액터 프로젝트는 거의 모든 리액티브 타입 변환에 필요한 도구(연산자 및 팩토리 메서드)를 제공한다. 이러한 도구는 일반적으로 다음과 같이 분류할 수 있다.
- 기존 시퀀스 변환
- 시퀀스 처리 과정을 살펴보는 메서드
- Flux 시퀀스를 분할 또는 결합
- 시간을 다루는 작업
- 데이터를 동기적으로 변환

